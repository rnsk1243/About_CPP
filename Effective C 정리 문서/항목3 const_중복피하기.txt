상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법

mutable은 괜찮은 방법이지만 골칫거리 전부를 씻어낼 수는 없다.
예를 들어 TextBlock의 operator[] 함수가 지금은 특정 문자의 참조자만 반환하고 있지만, 이것 말고도 여러 가지를 더 할 수도 있을 것입니다. 이럴 경우 어느덧 코드 판박이(const함수냐 아니냐만 다를뿐 내용은 같은 코드) 괴물이 나뒹굴고 있게 됩니다.
코드 중복이 많아 지면 컴파일 시간, 유지보수, 복잡함 등 여러가지 문제를 일으킬 수 있습니다. 
이 문제를 해결하려면 const 껍데기를 캐스팅으로 날리면 됩니다.
기본적으로 캐스팅은 일반적으로도 통념적으로도 썩 좋지 않은 아이디어지만 코드 중복보단 낫다.
const키워드가 붙는것을 빼면 완전히 같은 함수 이므로 캐스팅을 사용하여도 안전합니다.
그래서 결론은 안전성도 유지마면서 코드 중복을 피하는 방법은 비상수 operator[]가 상수 버전을 호출하도록 구현하는 것입니다.
예)
class TextBlock{

	public:
		...
		const char& operator[](std::size_t position) const // 이전과 동일
		{
			...
			return text[position];
		}
		char& operator[](std::size_t position) // 상수 버전 op[]를 호출하고 끝
		{
			return const_cast<char&>( static_cast<const TextBlock&>(*this)[position] );
			/*op[]의 반환 타입에 캐스팅을 적용, const를 떼어냅니다. *this의 타입에 const를 붙입니다. op[]의 상수 버전을 호출합니다. */
		};
	}
	...

};
위 코드를 보시면 캐스팅이 한번이 아니라 두번 되어 있습니다.
자, 지금 해야 하는 일은 비상수 operator[]가 상수 버전을 호출하게 하는 것입니다. 그런데 비상수 operator[]안에서 그냥 operator[]라고 적으면 그 자신이 재귀적으로 호출되고 맙니다.
이런 재귀호출을 피하기 위해서는 상수 operator[]를 호출하고 싶다고 표현해주어야 합니다. 이 표현을 하기 위해 *this의 타입 캐스팅입니다. 즉, 원래의 타입인 TextBlock&에서 const TextBlock&으로 바꾸는 것이죠.
결국 정리하면, 두 개의 캐스팅 중 첫 번째 것은 *this에 const를 붙이는 캐스팅이고(비상수 operator[]에서 상수 버전을 호출하기 위해), 두 번째 것은 상수 operator[]의 반환 값에서 const를 떼어내는 캐스팅 입니다.

const를 붙이는 캐스팅은 안전한 타입 변환(비상수 객체에서 상수 객체로 바꾸는)을 강제로 진행하는 것뿐이기 때문에 static_cast만 써도 딱 맞습니다. 반면에 const를 제거하는 캐스팅은 const_cast밖에 없으므로 별다른 선택의 여지가 없습니다.
앞의 방법을 뒤집어서 하는 쪽(코드 중복 회피를 위해 상수 버전이 비상수 버전을 호출하게 만드는 것)도 생각할 수 있는데 이는 옳지 않다. 상수 멤버 함수는 해당 객체의 논리적인 상태를 바꾸지 않겠다고 컴파일러와 굳게 약속한 함수인 반면, 비상수 멤버 함수는 이런 약속 같은 걸 하지 않습니다.
즉, 어쩌다가 상수 멤버에서 비상수 멤버를 호출하게 되면, 수정하지 않겠다고 약속한 그 객체를 배신하는 셈이 되고 그 객체는 변경될 위험에 빠질 수 있습니다. 상수 멤버 함수에서 비상수 멤버 함수를 호출하려면 const_cast를 적용해서 *this에 붙은 const를 떼어내야 하는데, 이게 온갖 재앙의 씨앗입니다.
비상수 멤버 함수안에서는 그 객체를 바꾸든 안 바꾸든 맘대로 할 수 있기 때문에, 비상수 멤버함수에서 상수 멤버 함수를 호출한다고 해서 특별히 잘못될 리가 없습니다. 위의 코드에서 보셨듯이 *this에 대해 static_cast가 제대로 작동하는 이유가 바로 이 때문입니다. const에 관련된 위험이 없거든요.

정리
const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 줍니다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있습니다.
컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 여러분은 개념적인 상수성을 사용해서 프로그래밍해야 합니다.
상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 번전이 상수 버전이 상수 버전을 호출하도록 만드세요.