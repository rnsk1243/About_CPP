포인터 객체를 리스트에 넣을경우 아무 호출없이 그냥 포인터가 들어감
객체를 리스트에 넣을 경우 복사생성자를 호출하여 복사한 값을 리스트에 들어감

함수에서 만들어진 지역변수는 함수가 종료될때 소멸자가 호출됨.
함수에서 지역변수가 리턴될때 우선 복사생성자가 호출된 후 소멸자가 호출됨.
복사생성자가 호출되는 경우는 값이 리턴될때임.(포인터, 래퍼런스)는 복사생성자 호출안됨. 아래예시
예외로
CTT* test2()
{
	CTT tt6(55);
	return &tt6;
} 이럴경우 소멸자만 호출됨. 다른 객체에 대입할경우 원본 주소가 들어가 있지만 소멸자가 호출
되었으므로 함수가 끝나는즉시 쓰래기값이 있음.
CTT& test2()
{
	CTT tt6(55);
	return tt6;
}
이럴경우 소멸자만 호출됨. 즉 원본이 리턴 되는 것. 근데 소멸 되었으므로 다른 객체에 
대입할경우 쓰래기값이 나옴

함수와 생성자의 매개변수로 *나&가 아닌 객체가 들어갈경우 복사 생성자가 호출됨.
즉, 매개변수의 객체가 소스가 되어 복사가 이루어진 것을 함수내에서 이용하는 것.
그리고 함수내에서 실컷이용하다가 함수가 종료될때 소멸자가 호출되어 해제됨.
근데 매개변수가 * 또는 &인 경우 복사 생성자가 호출 되지도 않고 복사 되지 않았으므로
소멸자 또한 호출 되지 않는다.

list<CTT> listTT; 이럴경우 리스트만 delete하면 모든 객체 자동 제거됨.
list<CTT*> listTT; 이럴경우 delete할때 리스트내 모든 객체 직접 제거해야함
list<CTT*>* listTT; 이것도 delete할때 리스트내 모든 객체 직접 제거해야함.
list<CTT>* listTT; 이것도 delete할때 리스트내 모든 객체 직접 제거해야함.

객체 생성할때 객체이름() <- 이런건 없다. 기본생성자 호출 안됨
예)
class TT{}
TT t(); <- 객체 안만들어짐 기본생성자 있어도 호출안됨.
TT t; <- 이렇게 해야 기본생성자 호출되어 객체 생성됨.
TT* t = new TT(); <- 이거는 포인터라서 기본생성자 호출되어 객체 생성됨.

main함수 안에서 for문을 돌리는건 상관 없다만.. 
for문안에서 객체를 생성(일반객체 스택에 들어가는 것)하면 그 객체는 계속 남는다.

char* 를 복사할때 복사할 문자개수보다 +1개 더 할당하고 꼭 마지막에 '\0'을 할당해야
해제할때 에러없이 해제된다.
int length = strlen(ch_) + 1;
		ch = new char[length];
		for (int i = 0; i < length-1; i++)
		{
			ch[i] = ch_[i];
		}
		ch[length-1] = '\0';
=====================================================
CListTest& listTest; // 멤버 참조변수

	CTargetManager(CListTest& listTest_):listTest(listTest_)
	{
		cout << "CTargetManager 생성자 호출" << endl;
	}

멤버 변수가 참조변수이면 멤버이니셜라이져에서 복사생성자가 호출되지 않는다.
멤버 변수가 일반 변수이면 멤버이니셜라이져에서 복사생성자가 호출되어 복사된 값이 들어간다.
이때 멤버 변수가 리스트라면 리스트에 들어있는 모든 원소들 각각 복사생성자로 복사되어 
복사된 리스트에 들어 간다.

====================================================
virtual 소멸자 생성시 
파생클래스 소멸자가 먼저 호출된 다음 기반 클래스 소멸자가 호출 됨.



